<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VERIFICA NIGHT and DISRUPTIVE DUTIES</title>
    <!-- Font Poppins da Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Carica il framework Tailwind CSS per uno stile moderno e reattivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #e0f2fe 0%, #d1e5f8 100%);
        }
        .btn-primary {
            background: linear-gradient(to right, #2563eb, #3b82f6);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        .result-legal {
            background-color: #4ade80;
            color: #166534;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        .result-illegal {
            background-color: #fca5a5;
            color: #991b1b;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        .result-special {
            background-color: #fde68a;
            color: #92400e;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        input[type="time"] {
            width: 100px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Contenitore principale dell'app -->
    <div class="bg-white p-8 rounded-3xl shadow-2xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Night and Disruptive Duties</h1>
        <p class="text-sm text-gray-500 text-center mb-8">Strumento per verificare se la regolamentazione prevista dal manuale nei paragrafi OMA 7.4.7 (1,2) Night Duties e 7.4.10.1 Consecutive Easyjet Disruptive Duties è stata correttamente applicata.</p>

        <!-- Sezione per l'inserimento dei turni -->
        <div class="mb-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Inserisci i tuoi turni (fino a 7 giorni):</h2>
            <div id="shiftInputs" class="flex flex-col gap-6">
                <!-- I campi di input verranno generati dinamicamente qui -->
            </div>
        </div>

        <!-- Pulsante di verifica e area per il risultato -->
        <div class="flex flex-col gap-4">
            <button id="verifyBtn" class="btn-primary text-white font-bold py-3 px-6 rounded-xl text-lg shadow-lg w-full">VERIFICA</button>
            <button id="clearBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-xl shadow-md transition-colors w-full mt-2">Cancella Tutto</button>
            <div id="resultBox" class="text-center font-bold text-md p-4 rounded-xl opacity-0 transform scale-95">
                <!-- Il risultato apparirà qui -->
            </div>
        </div>
    </div>

    <script>
        const verifyBtn = document.getElementById('verifyBtn');
        const clearBtn = document.getElementById('clearBtn');
        const shiftInputsContainer = document.getElementById('shiftInputs');
        const resultBox = document.getElementById('resultBox');

        // Genera 7 gruppi di campi di input per i turni
        for (let i = 1; i <= 7; i++) {
            const container = document.createElement('div');
            container.id = `day-container-${i}`;
            container.className = 'bg-blue-50 p-6 rounded-2xl shadow-inner flex flex-col gap-4';
            
            // Titolo per il giorno
            const dayTitle = document.createElement('h3');
            dayTitle.className = 'text-md font-semibold text-blue-800';
            dayTitle.textContent = `Giorno ${i}:`;
            container.appendChild(dayTitle);
            
            // Contenitore per i campi di input su una singola riga
            const inputsRow = document.createElement('div');
            inputsRow.className = 'flex flex-col sm:flex-row items-center justify-between gap-4';

            // Input per l'orario previsto
            const plannedGroup = document.createElement('div');
            plannedGroup.className = 'flex flex-row items-center gap-2';
            const plannedLabel = document.createElement('label');
            plannedLabel.className = 'text-gray-700 font-medium text-sm';
            plannedLabel.textContent = `Orario Previsto`;
            const plannedInput = document.createElement('input');
            plannedInput.type = 'time';
            plannedInput.id = `planned-shift-${i}`;
            plannedInput.className = 'p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500';
            plannedGroup.appendChild(plannedLabel);
            plannedGroup.appendChild(plannedInput);
            inputsRow.appendChild(plannedGroup);

            // Checkbox per il "Day Off"
            const offCheckboxGroup = document.createElement('div');
            offCheckboxGroup.className = 'flex items-center gap-2';
            const offCheckbox = document.createElement('input');
            offCheckbox.type = 'checkbox';
            offCheckbox.id = `off-day-${i}`;
            offCheckbox.className = 'h-5 w-5 text-blue-600 rounded focus:ring-blue-500';
            const offLabel = document.createElement('label');
            offLabel.htmlFor = `off-day-${i}`;
            offLabel.className = 'text-gray-700 font-medium text-sm select-none';
            offLabel.textContent = 'DAY OFF';
            offCheckboxGroup.appendChild(offCheckbox);
            offCheckboxGroup.appendChild(offLabel);
            inputsRow.appendChild(offCheckboxGroup);


            // Input per l'orario ritardato (opzionale)
            const delayedGroup = document.createElement('div');
            delayedGroup.className = 'flex flex-row items-center gap-2';
            const delayedLabel = document.createElement('label');
            delayedLabel.className = 'text-gray-700 font-medium text-sm';
            delayedLabel.textContent = `Orario Ritardato (Opzionale)`;
            const delayedInput = document.createElement('input');
            delayedInput.type = 'time';
            delayedInput.id = `delayed-shift-${i}`;
            delayedInput.className = 'p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500';
            delayedGroup.appendChild(delayedLabel);
            delayedGroup.appendChild(delayedInput);
            inputsRow.appendChild(delayedGroup);

            container.appendChild(inputsRow);
            shiftInputsContainer.appendChild(container);
            
            // Logica per gestire lo stato di "Day Off"
            offCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    plannedInput.value = '';
                    delayedInput.value = '';
                    plannedInput.disabled = true;
                    delayedInput.disabled = true;
                    plannedInput.placeholder = 'DAY OFF';
                    delayedInput.placeholder = 'DAY OFF';
                    plannedInput.style.backgroundColor = '#e5e7eb';
                    delayedInput.style.backgroundColor = '#e5e7eb';
                } else {
                    plannedInput.disabled = false;
                    delayedInput.disabled = false;
                    plannedInput.placeholder = '';
                    delayedInput.placeholder = '';
                    plannedInput.style.backgroundColor = '';
                    delayedInput.style.backgroundColor = '';
                }
            });

        }

        // Funzione per convertire un orario 'HH:mm' in minuti totali
        const timeToMinutes = (time) => {
            if (!time) return null;
            const [hours, minutes] = time.split(':').map(Number);
            return (hours * 60) + minutes;
        };

        // Funzione per verificare se un orario è un "Night Finish"
        const isNightFinish = (time) => {
            if (!time) return false;
            const minutes = timeToMinutes(time);
            const startNF = timeToMinutes('02:00');
            const endNF = timeToMinutes('04:59');
            return minutes >= startNF && minutes <= endNF;
        };

        // Funzione per verificare i "disruptive duties"
        const isDisruptiveDuty = (time) => {
            if (!time) return false;
            const minutes = timeToMinutes(time);
            const startDD = timeToMinutes('01:00');
            const endDD = timeToMinutes('06:59');
            return minutes >= startDD && minutes <= endDD;
        };

        // Funzione per ottenere l'orario finale di un giorno (ritardato se presente)
        const getFinalShiftTime = (dayIndex) => {
            const delayedInput = document.getElementById(`delayed-shift-${dayIndex}`);
            const plannedInput = document.getElementById(`planned-shift-${dayIndex}`);
            // Se il campo è disabilitato (DAY OFF), restituisce una stringa vuota
            if (plannedInput.disabled) {
                return '';
            }
            return delayedInput.value || plannedInput.value;
        };
        
        // Funzione di verifica principale basata sulle regole fornite
        const checkShifts = () => {
            // Include tutti i 7 giorni, inclusi i "Day Off"
            const allShifts = Array.from({length: 7}, (_, i) => ({ day: i + 1, time: getFinalShiftTime(i + 1) }));
            const shiftsWithTime = allShifts.filter(s => s.time !== '');
            
            if (shiftsWithTime.length < 1) {
                updateResult('legal', 'Non sono stati trovati turni da verificare.');
                return;
            }

            // Inizializza l'array per le ragioni legali
            const legalReasons = [];

            // Verifica delle regole sui "Night Finish"
            let nightFinishBlocks = [];
            let currentNFBlockStart = -1;

            for (let i = 0; i < shiftsWithTime.length; i++) {
                if (isNightFinish(shiftsWithTime[i].time)) {
                    if (currentNFBlockStart === -1) {
                        currentNFBlockStart = i;
                    }
                } else {
                    if (currentNFBlockStart !== -1) {
                        nightFinishBlocks.push({
                            start: currentNFBlockStart,
                            end: i - 1,
                            size: i - currentNFBlockStart
                        });
                    }
                    currentNFBlockStart = -1;
                }
            }
            if (currentNFBlockStart !== -1) {
                nightFinishBlocks.push({
                    start: currentNFBlockStart,
                    end: shiftsWithTime.length - 1,
                    size: shiftsWithTime.length - currentNFBlockStart
                });
            }

            for (const block of nightFinishBlocks) {
                if (block.size > 3) {
                    updateResult('illegal', `Illegale: blocco di ${block.size} turni notturni consecutivi, il limite massimo è 3.`);
                    return;
                }
                
                const precedingDutyIndex = block.start - 1;
                if (precedingDutyIndex >= 0) {
                    const precedingDutyDay = shiftsWithTime[precedingDutyIndex].day;
                    const precedingPlannedTime = document.getElementById(`planned-shift-${precedingDutyDay}`).value;
                    const precedingDelayedTime = document.getElementById(`delayed-shift-${precedingDutyDay}`).value;

                    if (block.size === 2) {
                        if (precedingPlannedTime && timeToMinutes(precedingPlannedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingPlannedTime) <= timeToMinutes('04:59')) {
                            updateResult('illegal', `Illegale: Il giorno (ad es. Giorno ${precedingDutyDay}) precedente ad una serie di 2 night duties non deve terminare oltre le 23:59.`);
                            return;
                        }
                        
                        if (precedingDelayedTime && timeToMinutes(precedingDelayedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingDelayedTime) <= timeToMinutes('04:59')) {
                             const illegalMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-red-800">TURNO ILLEGALE</h3>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        Il turno precedente ai 2 night duties consecutivi successivi (Giorno ${precedingDutyDay}) è terminato dopo le 23:59 ora locale a causa di un ritardo.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-red-800">ATTENZIONE</h4>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        L'assistente di volo potrà effettuare SOLO il primo dei due night duties consecutivi previsti.
                                    </p>
                                `;
                            updateResult('illegal', illegalMessage);
                            return;
                        }
                    } else if (block.size === 3) {
                        const precedingTimeMinutes = timeToMinutes(getFinalShiftTime(precedingDutyDay));
                        const precedingPlannedMinutes = timeToMinutes(precedingPlannedTime);
                        const limitStart = timeToMinutes('21:00');
                        const limitEnd = timeToMinutes('23:59');

                        if (precedingPlannedTime && precedingPlannedMinutes > limitStart) {
                             updateResult('illegal', `Illegale: blocco di 3 turni notturni consecutivi. Il turno precedente (Giorno ${precedingDutyDay}) ai tre giorni di night duties non può terminare oltre le ore 21:00`);
                             return;
                        }

                        if (precedingDelayedTime && timeToMinutes(precedingDelayedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingDelayedTime) <= timeToMinutes('04:59')) {
                             const illegalMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-red-800">TURNO ILLEGALE</h3>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        Il turno precedente ai 3 night duties consecutivi (Giorno ${precedingDutyDay}) è terminato dopo le 23:59 ora locale a causa di un ritardo.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-red-800">ATTENZIONE</h4>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        L'assitente di volo potrà svolgere SOLO il primo dei tre turni notturni consecutivi schedulati.
                                    </p>
                                `;
                             updateResult('illegal', illegalMessage);
                             return;
                        } else if (precedingTimeMinutes >= limitStart && precedingTimeMinutes <= limitEnd) {
                            const specialMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-yellow-800">ATTENZIONE</h3>
                                    <p class="text-sm font-normal text-yellow-800 mb-2">
                                        Il turno precedente ai 3 night duties (Giorno ${precedingDutyDay}) è terminato tra le 21:00 e le 23:59 ora locale.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-yellow-800">OPZIONI</h4>
                                    <ul class="list-disc list-inside text-sm font-normal text-yellow-800 text-left">
                                        <li>Scegliere di <strong>CONTINUARE</strong> con il roster pianificato portando a termine i 3 successivi night duties consecutivi;</li>
                                        <li>Scegliere di <strong>NON CONTINUARE</strong> con il roster pianificato; in questo caso si dovrà completare solo i primi due night duties consecutivi schedulati.</li>
                                    </ul>
                                    <p class="text-sm font-normal text-yellow-800 mt-4 mb-2">
                                        L'assistente di volo DOVRA' comunicare esplicitamente al comandante la sua intenzione di continuare o meno con il programma.
                                    </p>
                                    <p class="text-xs font-normal text-yellow-800 mt-4">
                                        Sul manuale - <u>OMA 7.4.7.2 Three Consecutive Night Finish Duties paragrafo 1.</u>
                                    </p>
                                `;
                            updateResult('special', specialMessage);
                            return;
                        }
                    }
                }
            }

            legalReasons.push("Non sono stati trovati blocchi illegali di <b>Night Finish Duties</b>.");

            // --- CONTROLLO DEI DISRUPTIVE DUTIES CONSECUTIVI ---
            let consecutiveDisruptiveCount = 0;
            let disruptiveDaysInBlock = [];
            
            for (let i = 0; i < allShifts.length; i++) {
                if (isDisruptiveDuty(allShifts[i].time)) {
                    consecutiveDisruptiveCount++;
                    disruptiveDaysInBlock.push(allShifts[i].day);
                } else {
                    if (consecutiveDisruptiveCount > 3) {
                        const daysString = disruptiveDaysInBlock.map(day => `Giorno ${day}`).join(', ');
                        const illegalMessage = `
                            <h3 class="text-xl font-bold mb-2 text-red-800">ILLEGALE</h3>
                            <p class="text-sm font-normal text-red-800 mb-2">
                                Hai un blocco di ${consecutiveDisruptiveCount} turni "disruptive" consecutivi, il limite massimo è 3.
                            </p>
                            <p class="text-sm font-normal text-red-800 mt-2 mb-2">
                                I giorni interessati sono: ${daysString}.
                            </p>
                        `;
                        updateResult('illegal', illegalMessage);
                        return;
                    }
                    consecutiveDisruptiveCount = 0;
                    disruptiveDaysInBlock.length = 0;
                }
            }
            
            // Controllo finale per un blocco consecutivo che termina l'array
            if (consecutiveDisruptiveCount > 3) {
                const daysString = disruptiveDaysInBlock.map(day => `Giorno ${day}`).join(', ');
                const illegalMessage = `
                    <h3 class="text-xl font-bold mb-2 text-red-800">ILLEGALE</h3>
                    <p class="text-sm font-normal text-red-800 mb-2">
                        Hai un blocco di ${consecutiveDisruptiveCount} turni "disruptive" consecutivi, il limite massimo è 3.
                    </p>
                    <p class="text-sm font-normal text-red-800 mt-2 mb-2">
                        I giorni interessati sono: ${daysString}.
                    </p>
                `;
                updateResult('illegal', illegalMessage);
                return;
            }

            legalReasons.push("Non sono stati trovati blocchi illegali di turni <b>disruptive consecutivi</b> (massimo 3).");


            // Ora controlla il totale dei disruptive duties in 7 giorni
            const disruptiveDays = allShifts.filter(s => isDisruptiveDuty(s.time));
            const totalDisruptiveCount = disruptiveDays.length;

            if (totalDisruptiveCount > 4) {
                const disruptiveDaysString = disruptiveDays.map(day => `Giorno ${day.day}`).join(', ');
                const illegalMessage = `
                            <h3 class="text-xl font-bold mb-2 text-red-800">ILLEGALE</h3>
                            <p class="text-sm font-normal text-red-800 mb-2">
                                Sono presenti ${totalDisruptiveCount} "disruptive" duties in 7 giorni, il limite massimo è 4.
                            </p>
                            <p class="text-sm font-normal text-red-800 mt-2 mb-2">
                                I giorni interessati sono: ${disruptiveDaysString}.
                            </p>
                        `;
                updateResult('illegal', illegalMessage);
                return;
            }

            legalReasons.push(`Il numero totale di turni <b>disruptive</b> in 7 giorni (${totalDisruptiveCount}) è conforme alla normativa (massimo 4).`);
            
            // Se tutto è andato bene, il turno è legale
            updateResult('legal', `
                <h3 class="text-xl font-bold mb-2 text-green-800">TURNO LEGALE</h3>
                <p class="text-sm font-normal text-green-800 mb-2">
                    La pianificazione del turno è conforme a tutte le normative verificate.
                </p>
                <ul class="list-disc list-inside text-sm font-normal text-green-800 text-left mt-4">
                    ${legalReasons.map(reason => `<li>${reason}</li>`).join('')}
                </ul>
            `);
        };

        const updateResult = (status, message) => {
            resultBox.classList.remove('result-legal', 'result-illegal', 'result-special', 'opacity-0', 'scale-95');
            resultBox.innerHTML = '';
            
            if (status === 'legal') {
                resultBox.classList.add('result-legal');
                resultBox.innerHTML = message;
            } else if (status === 'illegal') {
                resultBox.classList.add('result-illegal');
                resultBox.innerHTML = message;
            } else if (status === 'special') {
                resultBox.classList.add('result-special');
                resultBox.innerHTML = message;
            }
            
            resultBox.classList.remove('opacity-0', 'scale-95');
            resultBox.classList.add('opacity-100', 'scale-100');
        };

        verifyBtn.addEventListener('click', checkShifts);

        clearBtn.addEventListener('click', () => {
            for (let i = 1; i <= 7; i++) {
                const plannedInput = document.getElementById(`planned-shift-${i}`);
                const delayedInput = document.getElementById(`delayed-shift-${i}`);
                const offCheckbox = document.getElementById(`off-day-${i}`);

                plannedInput.value = '';
                delayedInput.value = '';
                offCheckbox.checked = false;
                plannedInput.disabled = false;
                delayedInput.disabled = false;
                plannedInput.placeholder = '';
                delayedInput.placeholder = '';
                plannedInput.style.backgroundColor = '';
                delayedInput.style.backgroundColor = '';
            }
            
            resultBox.classList.remove('opacity-100', 'scale-100', 'result-legal', 'result-illegal', 'result-special');
            resultBox.classList.add('opacity-0', 'scale-95');
            resultBox.innerHTML = '';
        });

        // Aggiungi un listener per ogni input per abilitare la verifica
        const inputs = shiftInputsContainer.querySelectorAll('input[type="time"]');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                // Rimuovi lo stato del risultato quando l'utente modifica un campo
                resultBox.classList.remove('opacity-100', 'scale-100', 'result-legal', 'result-illegal', 'result-special');
                resultBox.classList.add('opacity-0', 'scale-95');
            });
        });
    </script>
</body>
</html>
