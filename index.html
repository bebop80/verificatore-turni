<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VERIFICA NIGHT and DISRUPTIVE DUTIES</title>
    <!-- Font Poppins da Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Carica il framework Tailwind CSS per uno stile moderno e reattivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #e0f2fe 0%, #d1e5f8 100%);
        }
        .btn-primary {
            background: linear-gradient(to right, #2563eb, #3b82f6);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        .result-legal {
            background-color: #4ade80;
            color: #166534;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        .result-illegal {
            background-color: #fca5a5;
            color: #991b1b;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        .result-special {
            background-color: #fde68a;
            color: #92400e;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Contenitore principale dell'app -->
    <div class="bg-white p-8 rounded-3xl shadow-2xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Night and Disruptive Duties</h1>

        <!-- Sezione per l'inserimento dei turni -->
        <div class="mb-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Inserisci i tuoi turni (fino a 7 giorni):</h2>
            <div id="shiftInputs" class="flex flex-col gap-6">
                <!-- I campi di input verranno generati dinamicamente qui -->
            </div>
        </div>

        <!-- Pulsante di verifica e area per il risultato -->
        <div class="flex flex-col gap-4">
            <button id="verifyBtn" class="btn-primary text-white font-bold py-3 px-6 rounded-xl text-lg shadow-lg w-full">VERIFICA</button>
            <div id="resultBox" class="text-center font-bold text-md p-4 rounded-xl opacity-0 transform scale-95">
                <!-- Il risultato apparirà qui -->
            </div>
        </div>
    </div>

    <script>
        const verifyBtn = document.getElementById('verifyBtn');
        const shiftInputsContainer = document.getElementById('shiftInputs');
        const resultBox = document.getElementById('resultBox');

        // Genera 7 gruppi di campi di input per i turni
        for (let i = 1; i <= 7; i++) {
            const container = document.createElement('div');
            container.id = `day-container-${i}`;
            container.className = 'bg-blue-50 p-6 rounded-2xl shadow-inner grid grid-cols-1 sm:grid-cols-2 gap-4';
            
            // Titolo per il giorno
            const dayTitle = document.createElement('h3');
            dayTitle.className = 'col-span-1 sm:col-span-2 text-md font-semibold text-blue-800';
            dayTitle.textContent = `Giorno ${i}:`;
            container.appendChild(dayTitle);

            // Input per l'orario previsto
            const plannedGroup = document.createElement('div');
            plannedGroup.className = 'flex flex-col';
            const plannedLabel = document.createElement('label');
            plannedLabel.className = 'text-gray-700 font-medium mb-1 text-sm';
            plannedLabel.textContent = `Orario Previsto`;
            const plannedInput = document.createElement('input');
            plannedInput.type = 'time';
            plannedInput.id = `planned-shift-${i}`;
            plannedInput.className = 'p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500';
            plannedGroup.appendChild(plannedLabel);
            plannedGroup.appendChild(plannedInput);
            container.appendChild(plannedGroup);

            // Input per l'orario ritardato (opzionale)
            const delayedGroup = document.createElement('div');
            delayedGroup.className = 'flex flex-col';
            const delayedLabel = document.createElement('label');
            delayedLabel.className = 'text-gray-700 font-medium mb-1 text-sm';
            delayedLabel.textContent = `Orario Ritardato (Opzionale)`;
            const delayedInput = document.createElement('input');
            delayedInput.type = 'time';
            delayedInput.id = `delayed-shift-${i}`;
            delayedInput.className = 'p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500';
            delayedGroup.appendChild(delayedLabel);
            delayedGroup.appendChild(delayedInput);
            container.appendChild(delayedGroup);

            shiftInputsContainer.appendChild(container);
        }

        // Funzione per convertire un orario 'HH:mm' in minuti totali
        const timeToMinutes = (time) => {
            if (!time) return null;
            const [hours, minutes] = time.split(':').map(Number);
            return (hours * 60) + minutes;
        };

        // Funzione per verificare se un orario è un "Night Finish"
        const isNightFinish = (time) => {
            if (!time) return false;
            const minutes = timeToMinutes(time);
            const startNF = timeToMinutes('02:00');
            const endNF = timeToMinutes('04:59');
            return minutes >= startNF && minutes <= endNF;
        };

        // Funzione per verificare i "disruptive duties"
        const isDisruptiveDuty = (time) => {
            if (!time) return false;
            const minutes = timeToMinutes(time);
            const startDD = timeToMinutes('01:00');
            const endDD = timeToMinutes('06:59');
            return minutes >= startDD && minutes <= endDD;
        };

        // Funzione per ottenere l'orario finale di un giorno (ritardato se presente)
        const getFinalShiftTime = (dayIndex) => {
            const delayedInput = document.getElementById(`delayed-shift-${dayIndex}`);
            const plannedInput = document.getElementById(`planned-shift-${dayIndex}`);
            return delayedInput.value || plannedInput.value;
        };
        
        // Funzione di verifica principale basata sulle regole fornite
        const checkShifts = () => {
            const shifts = Array.from({length: 7}, (_, i) => getFinalShiftTime(i + 1))
                .filter(time => time !== '');
            
            if (shifts.length < 1) {
                updateResult('legal', 'Inserisci almeno un turno per la verifica');
                return;
            }

            // Verifica delle regole sui "Night Finish"
            let nightFinishBlocks = [];
            let currentNFBlockStart = -1;

            for (let i = 0; i < shifts.length; i++) {
                if (isNightFinish(shifts[i])) {
                    if (currentNFBlockStart === -1) {
                        currentNFBlockStart = i;
                    }
                } else {
                    if (currentNFBlockStart !== -1) {
                        nightFinishBlocks.push({
                            start: currentNFBlockStart,
                            end: i - 1,
                            size: i - currentNFBlockStart
                        });
                    }
                    currentNFBlockStart = -1;
                }
            }
            if (currentNFBlockStart !== -1) {
                nightFinishBlocks.push({
                    start: currentNFBlockStart,
                    end: shifts.length - 1,
                    size: shifts.length - currentNFBlockStart
                });
            }

            for (const block of nightFinishBlocks) {
                if (block.size > 3) {
                    updateResult('illegal', `Illegale: blocco di ${block.size} turni notturni consecutivi, il limite massimo è 3.`);
                    return;
                }
                
                const precedingDutyIndex = block.start - 1;
                if (precedingDutyIndex >= 0) {
                    const precedingPlannedTime = document.getElementById(`planned-shift-${precedingDutyIndex + 1}`).value;
                    const precedingDelayedTime = document.getElementById(`delayed-shift-${precedingDutyIndex + 1}`).value;

                    if (block.size === 2) {
                        if (precedingPlannedTime && timeToMinutes(precedingPlannedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingPlannedTime) <= timeToMinutes('04:59')) {
                            updateResult('illegal', `Illegale: Il giorno (in questione ad es. Giorno ${precedingDutyIndex + 1}) precedente ad una serie di 2 night duties non deve terminare oltre le 23:59.`);
                            return;
                        }
                        
                        if (precedingDelayedTime && timeToMinutes(precedingDelayedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingDelayedTime) <= timeToMinutes('04:59')) {
                             const illegalMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-red-800">TURNO ILLEGALE</h3>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        Il turno precedente ai 2 night duties consecutivi successivi (Giorno ${precedingDutyIndex + 1}) è terminato dopo le 23:59 ora locale a causa di un ritardo.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-red-800">ATTENZIONE</h4>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        L'assistente di volo potrà effettuare SOLO il primo dei due night duties consecutivi previsti.
                                    </p>
                                `;
                            updateResult('illegal', illegalMessage);
                            return;
                        }
                    } else if (block.size === 3) {
                        const precedingTimeMinutes = timeToMinutes(getFinalShiftTime(precedingDutyIndex + 1));
                        const precedingPlannedMinutes = timeToMinutes(precedingPlannedTime);
                        const limitStart = timeToMinutes('21:00');
                        const limitEnd = timeToMinutes('23:59');

                        if (precedingPlannedTime && precedingPlannedMinutes > limitStart) {
                             updateResult('illegal', `Illegale: blocco di 3 turni notturni consecutivi. Il turno precedente (Giorno ${precedingDutyIndex + 1}) ai tre giorni di night duties (orario compreso tra le 02:00 e le 04:59) non può terminare oltre le ore 21:00`);
                             return;
                        }

                        if (precedingDelayedTime && timeToMinutes(precedingDelayedTime) >= timeToMinutes('00:00') && timeToMinutes(precedingDelayedTime) <= timeToMinutes('04:59')) {
                             const illegalMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-red-800">TURNO ILLEGALE</h3>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        Il turno precedente ai 3 night duties consecutivi (Giorno ${precedingDutyIndex + 1}) è terminato dopo le 23:59 ora locale a causa di un ritardo.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-red-800">ATTENZIONE</h4>
                                    <p class="text-sm font-normal text-red-800 mb-2">
                                        In questo caso l'assitente di volo potrà svolgere SOLO il primo dei tre turni notturni consecutivi schedulati.
                                    </p>
                                `;
                             updateResult('illegal', illegalMessage);
                             return;
                        } else if (precedingTimeMinutes >= limitStart && precedingTimeMinutes <= limitEnd) {
                            const specialMessage = `
                                    <h3 class="text-xl font-bold mb-2 text-yellow-800">ATTENZIONE</h3>
                                    <p class="text-sm font-normal text-yellow-800 mb-2">
                                        Il turno precedente ai 3 night duties (Giorno ${precedingDutyIndex + 1}) è terminato tra le 21:00 e le 23:59 ora locale.
                                    </p>
                                    <h4 class="text-lg font-bold mt-4 mb-2 text-yellow-800">OPZIONI</h4>
                                    <ul class="list-disc list-inside text-sm font-normal text-yellow-800 text-left">
                                        <li>Scegliere di <strong>CONTINUARE</strong> con il roster pianificato portando a termine i 3 successivi night duties consecutivi;</li>
                                        <li>Scegliere di <strong>NON CONTINUARE</strong> con il roster pianificato; in questo caso dovrai completare solo i primi due night duties consecutivi schedulati.</li>
                                    </ul>
                                    <p class="text-sm font-normal text-yellow-800 mt-4 mb-2">
                                        L'assistente di volo DOVRA' comunicare esplicitamente al comandante la sua intenzione di continuare o meno con il programma.
                                    </p>
                                `;
                            updateResult('special', specialMessage);
                            return;
                        }
                    }
                }
            }

            // Verifica della consecutività dei "disruptive duties"
            let disruptiveBlocks = [];
            let currentDBBlockStart = -1;

            for (let i = 0; i < shifts.length; i++) {
                if (isDisruptiveDuty(shifts[i])) {
                    if (currentDBBlockStart === -1) {
                        currentDBBlockStart = i;
                    }
                } else {
                    if (currentDBBlockStart !== -1) {
                        disruptiveBlocks.push({
                            start: currentDBBlockStart,
                            end: i - 1,
                            size: i - currentDBBlockStart
                        });
                    }
                    currentDBBlockStart = -1;
                }
            }
            if (currentDBBlockStart !== -1) {
                disruptiveBlocks.push({
                    start: currentDBBlockStart,
                    end: shifts.length - 1,
                    size: shifts.length - currentDBBlockStart
                });
            }

            for (const block of disruptiveBlocks) {
                if (block.size > 3) {
                    updateResult('illegal', `Illegale: blocco di ${block.size} turni "disruptive" consecutivi, il limite massimo è 3.`);
                    return;
                }
            }

            // Verifica del limite di 4 "disruptive duties" in 7 giorni
            let disruptiveCount = 0;
            for (let i = 0; i < shifts.length; i++) {
                if (isDisruptiveDuty(shifts[i])) {
                    disruptiveCount++;
                }
            }

            if (disruptiveCount > 4) {
                updateResult('illegal', `Illegale: hai un totale di ${disruptiveCount} turni "disruptive" in 7 giorni, il limite massimo è 4.`);
                return;
            }
            
            updateResult('legal', 'Il turno è legale');
        };

        const updateResult = (status, message) => {
            resultBox.classList.remove('result-legal', 'result-illegal', 'result-special', 'opacity-0', 'scale-95');
            resultBox.innerHTML = '';
            
            if (status === 'legal') {
                resultBox.classList.add('result-legal');
                resultBox.innerHTML = 'Il turno è legale';
            } else if (status === 'illegal') {
                resultBox.classList.add('result-illegal');
                resultBox.innerHTML = message;
            } else if (status === 'special') {
                resultBox.classList.add('result-special');
                resultBox.innerHTML = message;
            }
            
            resultBox.classList.remove('opacity-0', 'scale-95');
            resultBox.classList.add('opacity-100', 'scale-100');
        };

        verifyBtn.addEventListener('click', checkShifts);

        // Aggiungi un listener per ogni input per abilitare la verifica
        const inputs = shiftInputsContainer.querySelectorAll('input[type="time"]');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                // Rimuovi lo stato del risultato quando l'utente modifica un campo
                resultBox.classList.remove('opacity-100', 'scale-100', 'result-legal', 'result-illegal', 'result-special');
                resultBox.classList.add('opacity-0', 'scale-95');
            });
        });
    </script>
</body>
</html>
